/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f1xx.h"
#include "led.h"
//#include "system.h"
#include "hd44780display.h"
#include "encoder.h"
#include <unistd.h>
#include <string.h>
#include "lampdisplay.h"
#include "buttons.h"
#include "lampdriver.h"

volatile struct Button bt0;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


Led* justLed;

Led* lamps[8];
LampDriver* lampDriver;

Encoder* enco;
LampDisplay display;
HD44780Display lcd;//display
bool flagRtc = 0;
bool flagButt = 0;
volatile uint32_t systemTimerValue = 0;

void SysTick_Handler(void)
{
	systemTimerValue++;
	if(systemTimerValue%200) flagButt = 1;
	if(bt0.ipt) bt0.tmd++;
	if(bt0.st)bt0.tm++;
}

/*
void delayms(uint32_t ms)
{

	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;

		// Wait for a specified number of milliseconds
		delayCounter = 0;
		while (delayCounter < ms);

		// Disable the SysTick timer
		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;
}
SysTick->LOAD = (uint32_t)((SystemCoreClock / 1000) - 1);

		// Reset the SysTick counter value.
		SysTick->VAL = 0UL;

		// Set SysTick source and IRQ.
		SysTick->CTRL = (SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_TICKINT_Msk);
	*/


void RTC_IRQHandler(void)
{
	flagRtc = 1;
	if(RTC->CRL&RTC_CRL_SECF ){ RTC->CRL&=~RTC_CRL_SECF;}
}

void EXTI0_IRQHandler(void)
{
	EXTI->PR|=0x01;
	//justLed->tuggle();
	if(!(bt0.buttBit&RG_BUTT_INPREG))
	{bt0.ipt = 1; bt0.st = 1; }
	}


void initExtIntGPIO()
{

	RCC->APB2ENR |= RCC_APB2ENR_AFIOEN; //Тактирование AFIO
	//exti pins
//#ifdef ENC_BT0
	GPIOB->CRL &= ~GPIO_CRL_MODE0_0;
	GPIOB->CRL &= ~GPIO_CRL_MODE0_1;
	GPIOB->CRL &= ~GPIO_CRL_CNF0;
	GPIOB->CRL |= GPIO_CRL_CNF0_1;
	GPIOB->ODR |= GPIO_ODR_ODR0;

	//AFIO->EXTICR
	AFIO->EXTICR[0] |= AFIO_EXTICR1_EXTI0_PB;
	EXTI->IMR|=EXTI_IMR_MR0;
	EXTI->FTSR|=EXTI_FTSR_TR0;



}

//Encoder with timer
void initEncoderGPIO()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;  // Enable PORTA Periph clock
	GPIOB->CRL &= ~(GPIO_CRL_CNF6_0 | GPIO_CRL_CNF7_0);
	GPIOB->CRL |= GPIO_CRL_CNF7_1 | GPIO_CRL_CNF6_1;
	GPIOB->CRL &= ~(GPIO_CRL_MODE6_0|GPIO_CRL_MODE6_1|GPIO_CRL_MODE7_0|GPIO_CRL_MODE7_1);
	GPIOB->ODR |= GPIO_ODR_ODR6 | GPIO_ODR_ODR7;
}

void initTimer4()
{
	RCC->APB1ENR |= RCC_APB1ENR_TIM4EN;
	initEncoderGPIO();
	TIM4->CCMR1 |= TIM_CCMR1_CC1S_0; //capture compare on
	TIM4->SMCR|= TIM_SMCR_SMS_0;//счет энкодера только по одному каналу
	TIM4->CCER &= ~(TIM_CCER_CC1P);//?
	TIM4->ARR = 120;
	TIM4->CR1 |= TIM_CR1_CEN;//|TIM_CR1_ARPE;
	TIM4->CNT = 0;

}
void enableInterrupts()
{
	NVIC_EnableIRQ(RTC_IRQn);
NVIC_EnableIRQ(EXTI0_IRQn);
NVIC_EnableIRQ(SysTick_IRQn);
NVIC_SetPriority(SysTick_IRQn, 4);

}

void setWriteModeRTC(char on)
{
	if(on){ while(!(RTC->CRL&RTC_CRL_RTOFF)); RTC->CRL|=RTC_CRL_CNF;}
	else { RTC->CRL&=~RTC_CRL_CNF;}
}
void setTimeInSecondsRtc(unsigned int time)
{
	//PWR->CR|=PWR_CR_DBP;
	setWriteModeRTC(1);
	RTC->CNTL = (unsigned short int)time;
	RTC->CNTH = (unsigned short int)(time>>16);
	setWriteModeRTC(0);
	//PWR->CR&=~PWR_CR_DBP;
}

void setTimeRTC(char hour, char min, char sec)
{
	unsigned int seconds = sec+min*60+hour*3600;
	setTimeInSecondsRtc(seconds);
}

unsigned int getTimeInSecondsRTC()
{
	unsigned int seconds;
	//PWR->CR|= PWR_CR_DBP;
	seconds = RTC->CNTH;
	seconds = (seconds<<16)&0xffff0000;
	seconds|=RTC->CNTL;
	//PWR->CR&=~PWR_CR_DBP;
	return seconds;
}

unsigned int convertTimeToSeconds(char hour, char minute, char seconds)
{
	return seconds+minute*60+hour*3600;
}

void getTimeRTC(uint8_t* hour, uint8_t *minute, uint8_t* seconds)
{
	unsigned int sec;
  sec = getTimeInSecondsRTC();
	*hour = sec/3600; sec = sec%3600;
	*minute = sec/60; *seconds = sec%60;
	if((*hour) >= 24)
	{

		*hour = 0; *seconds = 0; *minute = 0;
		setTimeRTC(0,0,0);
	}
}


char initRTC()
{

	RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
	PWR->CR |= PWR_CR_DBP;

	if((RCC->BDCR & RCC_BDCR_RTCEN) != RCC_BDCR_RTCEN)
	{
		RCC->BDCR |= RCC_BDCR_BDRST;
		RCC->BDCR &= ~RCC_BDCR_BDRST;

		RCC->BDCR |= RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE;

		RTC->CRL |= RTC_CRL_CNF;
		RTC->PRLL = 0x7fff;
		RTC->CRH |= RTC_CRH_SECIE;
		RTC->CRL &= ~RTC_CRL_CNF;

		RCC->BDCR |= RCC_BDCR_LSEON;
		while((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON);

		RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
		while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF);

		RTC->CRL &= ~RTC_CRL_SECF;
	//	PWR->CR &= ~PWR_CR_DBP;
		return 0;
	}
	else
	{
		RTC->CRH |= RTC_CRH_SECIE;
		//PWR->CR &= ~PWR_CR_DBP;
		return 1;
	}
}

void initLampsGPIO()
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;  // Enable PORTA Periph clock
	GPIOA->CRH &= ~(GPIO_CRH_MODE9 | GPIO_CRH_CNF9);
	GPIOA->CRH |= GPIO_CRH_MODE9_0;

	GPIOA->CRH &= ~(GPIO_CRH_MODE10 | GPIO_CRH_CNF10);
	GPIOA->CRH |= GPIO_CRH_MODE10_0;

	GPIOA->CRH &= ~(GPIO_CRH_MODE11 | GPIO_CRH_CNF11);
	GPIOA->CRH |= GPIO_CRH_MODE11_0;

	GPIOA->CRH &= ~(GPIO_CRH_MODE12 | GPIO_CRH_CNF12);
	GPIOA->CRH |= GPIO_CRH_MODE12_0;

	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;  // Enable PORTA Periph clock
	GPIOB->CRH &= ~(GPIO_CRH_MODE12 | GPIO_CRH_CNF12);
	GPIOB->CRH |= GPIO_CRH_MODE12_0;

	GPIOB->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);
	GPIOB->CRH |= GPIO_CRH_MODE13_0;

	GPIOB->CRH &= ~(GPIO_CRH_MODE14 | GPIO_CRH_CNF14);
	GPIOB->CRH |= GPIO_CRH_MODE14_0;

	GPIOB->CRH &= ~(GPIO_CRH_MODE15 | GPIO_CRH_CNF15);
	GPIOB->CRH |= GPIO_CRH_MODE15_0;
}

//A9 A10 A11 A12 B12 B13 B14 B15
void initLamps()
{
	initLampsGPIO();

	lamps[0] = new Led(&GPIOA->ODR, GPIO_ODR_ODR9, 0);
	lamps[1] = new Led(&GPIOA->ODR, GPIO_ODR_ODR10, 0);
	lamps[2] = new Led(&GPIOA->ODR, GPIO_ODR_ODR11, 0);
	lamps[3] = new Led(&GPIOA->ODR, GPIO_ODR_ODR12, 0);

	lamps[4] = new Led(&GPIOB->ODR, GPIO_ODR_ODR12, 0);
	lamps[5] = new Led(&GPIOB->ODR, GPIO_ODR_ODR13, 0);
	lamps[6] = new Led(&GPIOB->ODR, GPIO_ODR_ODR14, 0);
	lamps[7] = new Led(&GPIOB->ODR, GPIO_ODR_ODR15, 0);

	int i = 0;
	while(i<8)
	{
		lamps[i]->off();
		i++;
	}
}

int main(void)
{
	systemClockInit();
	SysTick_Config(SYS_TIMER_FREQ);
	WWDG->CR &= ~WWDG_CR_WDGA;
	///
	initTimer4();




	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;  // Enable PORTC Periph clock
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;  // Enable PORTA Periph clock
	/*OTHER PINS*/
	//just led
	GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);
	GPIOC->CRH |= GPIO_CRH_MODE13_0;

	GPIOA->CRL|= GPIO_CRL_MODE2_0 | GPIO_CRL_MODE2_1 | GPIO_CRL_MODE3_0 | GPIO_CRL_MODE3_1 | GPIO_CRL_MODE4_0 | GPIO_CRL_MODE4_1 | GPIO_CRL_MODE5_0 | GPIO_CRL_MODE5_1 | GPIO_CRL_MODE6_0 | GPIO_CRL_MODE6_1 | GPIO_CRL_MODE7_0 | GPIO_CRL_MODE7_1 ;
	GPIOA->CRL&= ~(GPIO_CRL_CNF2_1 | GPIO_CRL_CNF3_1 | GPIO_CRL_CNF4_1 | GPIO_CRL_CNF5_1  |  GPIO_CRL_CNF6_1 | GPIO_CRL_CNF7_1 );
	GPIOA->CRL|= GPIO_CRL_CNF2_0 | GPIO_CRL_CNF3_0 | GPIO_CRL_CNF4_0 | GPIO_CRL_CNF5_0  |  GPIO_CRL_CNF6_0 | GPIO_CRL_CNF7_0;


	if(!initRTC())setTimeRTC(0,0,0);

	initExtIntGPIO();

	enableInterrupts();


	justLed = new Led(&GPIOC->ODR, GPIO_ODR_ODR13,0);

	enco = new Encoder(&TIM4->CNT, &TIM4->ARR, 10, 2);


	initLamps();
	lampDriver = new LampDriver(8,lamps);
	PinsMask lcdpm;//for gpio
	//debug
	//lcdpm.E = GPIOPIN_5;// dng pa4
	//lcdpm.RS = GPIOPIN_4;//0x00000010;//dbg pa5
	//lcdpm.DB4 = GPIOPIN_10;//0x00000400;//bdg pa10
	//lcdpm.DB5 = GPIOPIN_11;//0x00000800;//dbg pa11
	//lcdpm.DB6 = GPIOPIN_12;//0x00001000;//dbg pa12
	//lcdpm.DB7 = GPIOPIN_15;//0x00008000;//dbg pa15
	//lcd.setInterface(HD44780Display::IFACE_PARRALEL4, &(GPIOA->ODR), lcdpm);

	//work
	lcdpm.E = GPIOPIN_3;// dng pa4
	lcdpm.RS = GPIOPIN_2;//0x00000010;//dbg pa5
	lcdpm.DB4 = GPIOPIN_4;//0x00000400;//bdg pa10
	lcdpm.DB5 = GPIOPIN_5;//0x00000800;//dbg pa11
	lcdpm.DB6 = GPIOPIN_6;//0x00001000;//dbg pa12
	lcdpm.DB7 = GPIOPIN_7;//0x00008000;//dbg pa15
	lcd.setInterface(HD44780Display::IFACE_PARRALEL4, &(GPIOA->ODR), lcdpm);

	lcd.init(2, 16);
	//	lcd.print(0, static_cast<char*>("-055C      +999C"));
	//		lcd.print(1, "777.0W     99.9V");

	display.setDisplay(&lcd);

lamps[0]->on();
lamps[4+1]->on();
lamps[2]->on();
lamps[4+2]->on();
	int i = 0;
	/* Loop forever */
	for(;;)

	{
		i++;
		//	if(i>100000)
		//	{
		//ledTuggle();
		//delay_ms(1000);

		i = 0;
		signed char es;
		unsigned short int ev;
		char bs;
		//	es = enco->handleEncoder(&ev);
		//	char bs = handleButtInt(&bt0);
		uint8_t h, m, s;

			if(flagRtc)
			{
				flagRtc = 0;
				getTimeRTC(&h, &m, &s);
				justLed->tuggle();
				display.drawTime(h, m, s);
			}

		if(systemTimerValue%1000 == 0)
		{
		//	justLed->tuggle();


		}

		if(flagButt)
		{
			es = enco->handleEncoder(&ev);
			bs = handleButtInt(&bt0);



					//	//display.drawLampStatus(3, 2, 1, 0);
		//	if(bs == BUTT_SHORTCLICK)display.drawLampChannelsConfig(0, 0, 17, 1);
			//else if(bs == BUTT_LONGCLICK)display.drawLampChannelsConfig(1, 0, 17, 0);
			//else if(bs == BUTT_DOUBLECLICK)display.drawLampChannelsConfig(2, 1, 17, 1);
			display.drawLampStatus(lamps);
			flagButt = 0;
			display.refresh();
		}

		i = 0;



	}
}
